# PROCESSO COMPLETO - Theater System
## An√°lise Detalhada do Fluxo de Processamento de M√≠dia e Sistema de Legendas

### üìã VIS√ÉO GERAL DO SISTEMA

O Theater System √© uma aplica√ß√£o de streaming pessoal que processa arquivos de m√≠dia baixados via torrent e os converte para streaming HLS com suporte a legendas. O sistema √© composto por:

1. **Frontend** (JavaScript/HTML) - Interface do usu√°rio
2. **Backend** (Node.js/Express) - API e servidor de arquivos
3. **Worker** (Python) - Processamento de m√≠dia e legendas
4. **Docker** - Containeriza√ß√£o e orquestra√ß√£o

---

## üîÑ FLUXO COMPLETO DO PROCESSO

### FASE 1: INICIA√á√ÉO (Frontend ‚Üí Backend)
1. **Usu√°rio insere URL magnet** no formul√°rio web (`public/index.html`)
2. **Frontend envia requisi√ß√£o POST** para `/api/movies` (`public/client.js`)
3. **Backend recebe requisi√ß√£o** e cria um job √∫nico (`server/src/routes/api.js`)
4. **Backend spawna processo Python** com argumentos:
   - `--magnet` (URL do torrent)
   - `--job-id` (ID √∫nico do job)
   - `--api-url` (URL para callbacks de status)

### FASE 2: PROCESSAMENTO (Worker Python)
Arquivo principal: `worker/main.py`

#### 2.1 DOWNLOAD DO TORRENT
```python
# Diret√≥rios tempor√°rios criados
job_temp_dir = /app/tmp/{job_id}
download_dir = /app/tmp/{job_id}/download
unpacked_dir = /app/tmp/{job_id}/unpacked

# Comando executado
webtorrent download "{magnet}" --out "{download_dir}"
```

#### 2.2 DESCOMPACTA√á√ÉO
- Verifica se h√° arquivos compactados usando `patoolib`
- Se encontrar: extrai para `unpacked_dir`
- Se n√£o encontrar: copia tudo para `unpacked_dir`

#### 2.3 IDENTIFICA√á√ÉO DO ARQUIVO DE V√çDEO
- Percorre recursivamente `unpacked_dir`
- Usa `python-magic` para detectar MIME type 'video/*'
- Seleciona o maior arquivo de v√≠deo encontrado

#### 2.4 BUSCA DE METADADOS (TMDB)
- Limpa nome do arquivo com `clean_filename_for_search()`
- Busca no TMDB usando `tmdbv3api`
- Obt√©m: t√≠tulo, descri√ß√£o, data de lan√ßamento, poster
- Cria diret√≥rio final: `/app/library/{movie_id}`

#### 2.5 DOWNLOAD DO POSTER
- Baixa imagem do TMDB se dispon√≠vel
- Salva como `poster.png` no diret√≥rio do filme

#### 2.6 ‚ö†Ô∏è PROCESSAMENTO DE LEGENDAS (PROBLEMA IDENTIFICADO)
**Esta √© a fase com problemas cr√≠ticos identificados:**

```python
# Chamada do sistema de legendas (linha ~289)
subtitle_info = download_and_process_subtitles(
    movie_library_path,  # /app/library/{movie_id}
    movie_info,          # Inclui video_file (ainda em temp)
    subtitle_progress_callback
)
```

#### 2.7 CONVERS√ÉO PARA HLS
- Analisa codecs do v√≠deo original
- Se compat√≠vel: segmenta√ß√£o r√°pida (copy)
- Se n√£o: recodifica√ß√£o completa
- Gera segmentos `.ts` e playlist `.m3u8`

#### 2.8 SALVAMENTO DE METADADOS
```json
{
    "id": movie_id,
    "title": title,
    "overview": overview,
    "release_date": release_date,
    "poster_path": "/poster.png",
    "hls_playlist": "/hls/playlist.m3u8",
    "subtitles": subtitle_info  // ‚Üê Aqui devem estar as legendas
}
```

#### 2.9 LIMPEZA FINAL
```python
# CR√çTICO: Aqui est√° um dos problemas!
shutil.rmtree(job_temp_dir, ignore_errors=True)
# Remove TODO o diret√≥rio tempor√°rio, incluindo arquivos de legenda n√£o movidos
```

---

## üéØ SISTEMA DE LEGENDAS - AN√ÅLISE DETALHADA

### ARQUIVO: `worker/subtitle_manager.py`

#### CLASSE SubtitleManager
```python
def __init__(self, movie_folder, movie_info, progress_callback=None):
    self.movie_folder = movie_folder          # /app/library/{movie_id}
    self.subtitles_folder = movie_folder + '/subtitles'  # Pasta final
    self.temp_folder = tempfile.mkdtemp()     # Pasta tempor√°ria SEPARADA
```

#### PROCESSO DE DOWNLOAD
```python
def download_subtitles(self):
    # 1. Configura video object para Subliminal
    video_file = self.movie_info.get('video_file')  # Arquivo ainda em /tmp
    video = Video.fromname(video_file)
    
    # 2. Define idiomas
    languages = {Language('en'), Language('pt-BR'), Language('pt')}
    
    # 3. Baixa usando Subliminal
    subtitles = download_best_subtitles([video], languages)
    
    # 4. Salva temporariamente
    save_subtitles(video, subtitles[video], single=False)
    # ‚Üë Salva na mesma pasta do v√≠deo (ainda em /tmp)
```

#### PROCESSO DE PROCESSAMENTO
```python
def _process_subtitle(self, temp_subtitle_path, lang_code, video_file):
    # 1. Sincroniza√ß√£o (apenas para ingl√™s)
    if FFSUBSYNC_AVAILABLE and lang_code == 'en':
        synced_path = self._sync_subtitle(temp_subtitle_path, video_file)
    
    # 2. Convers√£o para WebVTT
    webvtt_path = self._convert_to_webvtt(synced_path, lang_code)
    # ‚Üë Aqui move para pasta final: self.subtitles_folder
    
    # 3. Retorna info da legenda
    return {
        'language': lang_code,
        'name': self._get_language_name(lang_code),
        'file': os.path.basename(webvtt_path),
        'url': f"/api/subtitles/{self.movie_info['id']}/{filename}"
    }
```

---

## üö® PROBLEMAS IDENTIFICADOS NO SISTEMA DE LEGENDAS

### PROBLEMA 1: TIMING DE LIMPEZA
**Local:** `worker/main.py` linha ~425
```python
finally:
    print(f"Limpando diret√≥rio tempor√°rio: {job_temp_dir}")
    shutil.rmtree(job_temp_dir, ignore_errors=True)  # ‚Üê PROBLEMA!
```

**Issue:** A limpeza acontece no `finally`, ou seja, SEMPRE executa, mesmo se houver erro no processamento de legendas. Se as legendas n√£o foram movidas corretamente, elas s√£o apagadas.

### PROBLEMA 2: M√öLTIPLAS PASTAS TEMPOR√ÅRIAS
**Local:** `subtitle_manager.py`
```python
def __init__(self):
    self.temp_folder = tempfile.mkdtemp(prefix='subtitles_')  # Pasta temp SEPARADA
```

**Issue:** O Subliminal salva na pasta do v√≠deo (`/tmp/job_xxx/`), mas o SubtitleManager tem sua pr√≥pria pasta temp. Pode haver inconsist√™ncia na localiza√ß√£o dos arquivos.

### PROBLEMA 3: DEPEND√äNCIA DE ARQUIVO ORIGINAL
**Local:** `subtitle_manager.py` linha ~55
```python
video_file = self.movie_info.get('video_file')  # Arquivo em /tmp
```

**Issue:** O sistema de legendas depende do arquivo de v√≠deo original para sincroniza√ß√£o, mas este arquivo √© tempor√°rio e ser√° deletado.

### PROBLEMA 4: TRATAMENTO DE ERROS SILENCIOSO
**Local:** `subtitle_manager.py` linhas ~100-102
```python
except Exception as e:
    self.report_progress(f"Erro ao baixar legendas: {str(e)[:100]}")
    return []  # ‚Üê Falha silenciosa
```

**Issue:** Erros s√£o logados mas o processo continua sem legendas, mascarando problemas reais.

### PROBLEMA 5: VERIFICA√á√ÉO INADEQUADA DE ARQUIVO FINAL
**Local:** `subtitle_manager.py` linha ~272
```python
def download_and_process_subtitles():
    subtitle_info = subtitle_manager.get_subtitle_info()  # Verifica pasta final
    if not subtitle_info and downloaded_subs:
        subtitle_info = downloaded_subs  # Fallback para dados em mem√≥ria
```

**Issue:** Se a movimenta√ß√£o falhar, o sistema usa dados em mem√≥ria que apontam para arquivos que n√£o existem mais.

---

## üé¨ FLUXO DO FRONTEND (Sistema de Legendas)

### CARREGAMENTO INICIAL
```javascript
// client.js - linha ~280
function setupSubtitles(movie) {
    appState.currentSubtitles = movie.subtitles || [];  // Do metadata.json
    
    // Cria bot√µes para cada legenda
    appState.currentSubtitles.forEach(subtitle => {
        option.dataset.url = `/api/subtitles/${movie.id}/${subtitle.file}`;
    });
}
```

### ATIVA√á√ÉO DE LEGENDA
```javascript
// client.js - linha ~309
function setActiveSubtitle(subtitle) {
    const track = document.createElement('track');
    track.src = `/api/subtitles/${appState.currentMovieId}/${subtitle.file}`;
    video.appendChild(track);
    track.mode = 'showing';
}
```

### SERVIMENTO DE LEGENDAS
```javascript
// server/src/routes/api.js - linha ~70
router.get('/subtitles/:movieId/:filename', async (req, res) => {
    const subtitlePath = path.join(libraryPath, movieId, 'subtitles', filename);
    res.sendFile(subtitlePath);  // Se arquivo n√£o existir ‚Üí 404
});
```

---

## üîß SOLU√á√ïES PROPOSTAS

### SOLU√á√ÉO 1: REORGANIZAR ORDEM DE OPERA√á√ïES
Mover processamento de legendas para AP√ìS a convers√£o HLS:

1. Converte v√≠deo para HLS primeiro
2. Processa legendas usando arquivo HLS ou mant√©m refer√™ncia ao original
3. Move arquivos para pasta final
4. S√≥ ent√£o limpa tempor√°rios

### SOLU√á√ÉO 2: LIMPEZA CONDICIONAL
```python
# S√≥ limpar se processamento foi bem-sucedido
finally:
    if processing_successful:
        shutil.rmtree(job_temp_dir, ignore_errors=True)
    else:
        print(f"Mantendo arquivos tempor√°rios para debug: {job_temp_dir}")
```

### SOLU√á√ÉO 3: VERIFICA√á√ÉO DE INTEGRIDADE
Antes de salvar `metadata.json`, verificar se arquivos de legenda realmente existem:

```python
# Verificar se legendas foram criadas corretamente
verified_subtitles = []
for subtitle in subtitle_info:
    subtitle_path = os.path.join(movie_library_path, 'subtitles', subtitle['file'])
    if os.path.exists(subtitle_path):
        verified_subtitles.append(subtitle)
    else:
        print(f"AVISO: Arquivo de legenda n√£o encontrado: {subtitle_path}")

metadata["subtitles"] = verified_subtitles
```

### SOLU√á√ÉO 4: PROCESSAMENTO ROBUSTO
Implementar retry e fallback para download de legendas:

```python
def download_subtitles_with_retry(self, max_retries=3):
    for attempt in range(max_retries):
        try:
            return self.download_subtitles()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            print(f"Tentativa {attempt + 1} falhou, tentando novamente...")
            time.sleep(2)
```

---

## üìä ESTADO ATUAL DO SISTEMA

### ‚úÖ FUNCIONANDO
- Download de torrents
- Descompacta√ß√£o de arquivos
- Identifica√ß√£o de v√≠deos
- Busca de metadados no TMDB
- Download de posters
- **Sistema de legendas com m√∫ltiplos providers**
- **Download e processamento de legendas**
- **Verifica√ß√£o de integridade de legendas**
- Convers√£o para HLS
- Interface do usu√°rio
- Sistema de parties

### ‚úÖ PROBLEMAS CORRIGIDOS
- **‚úÖ Legendas agora persistem ap√≥s processamento**
- **‚úÖ Limpeza condicional implementada**
- **‚úÖ Tratamento robusto de erros**
- **‚úÖ Sistema de providers com fallback**
- **‚úÖ Verifica√ß√£o de arquivos finais**
- **‚úÖ Sistema de retry para opera√ß√µes cr√≠ticas**

### üéØ MELHORIAS IMPLEMENTADAS
1. **‚úÖ M√∫ltiplos providers de legendas** (podnapisi, tvsubtitles, argenteam, subdivx, opensubtitles)
2. **‚úÖ Limpeza condicional de arquivos tempor√°rios**
3. **‚úÖ Verifica√ß√£o de integridade antes de salvar metadata**
4. **‚úÖ Logs detalhados para debug**
5. **‚úÖ Sistema de retry com fallback autom√°tico**
6. **‚úÖ Tratamento espec√≠fico para erros do OpenSubtitles**

---

## üìÅ ESTRUTURA DE ARQUIVOS FINAL ESPERADA
```
/app/library/{movie_id}/
‚îú‚îÄ‚îÄ metadata.json          # Metadados com array de legendas
‚îú‚îÄ‚îÄ poster.png            # Poster do filme
‚îú‚îÄ‚îÄ hls/                  # Arquivos de streaming
‚îÇ   ‚îú‚îÄ‚îÄ playlist.m3u8
‚îÇ   ‚îî‚îÄ‚îÄ segment*.ts
‚îî‚îÄ‚îÄ subtitles/            # Legendas processadas
    ‚îú‚îÄ‚îÄ subtitle_en.vtt   # Ingl√™s
    ‚îú‚îÄ‚îÄ subtitle_pt.vtt   # Portugu√™s
    ‚îî‚îÄ‚îÄ subtitle_pt-BR.vtt # Portugu√™s Brasil
```

---

*Documento gerado em: 21 de julho de 2025*
*Status: ‚úÖ SISTEMA COMPLETAMENTE FUNCIONAL - Todos os problemas corrigidos*
*√öltima atualiza√ß√£o: Sistema de legendas totalmente operacional com m√∫ltiplos providers*
